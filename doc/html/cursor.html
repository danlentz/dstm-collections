<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">

<html>
<head>
<link rel="Stylesheet" type="text/css" href="../../../cldoc/src/cludg.css"/>
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1"/>
<title>
cursor</title>
</head>
<body>
<div id="navbar">
<table cellspacing="0" cellpadding="0" border="0" style="width: 100%;">
<colgroup span="3">
<col width="0*"/>
<col width="0*"/>
<col width="1*"/>
</colgroup>
<tr>
<td align="left" valign="baseline">
<a href="tree.html">
Prev:&nbsp;tree</a>
<br/>
<a href="set.html">
Next:&nbsp;set</a>
</td>
<td>
&nbsp;&nbsp;&nbsp;&nbsp;</td>
<td align="left" valign="baseline">
<span class="upchain">
<b>
cursor</b>
<br/>
<a href="index.html">
Index</a>
</span>
&nbsp;&nbsp;&nbsp;&nbsp;</td>
</tr>
</table>
</div>
<div class="cludg-doc-body">
<h2>
cursor
</h2>
<table style="width: 100%;" class="summary-table">
<tr class="table-heading-color">
<th class="summary" colspan="2">
Function summary</th>
</tr>
<tr class="table-row-color">
<td class="summary-name">
<a href="cursor.html#_g3797">
make-cursor</a>
</td>
<td class="summary">
collection</td>
</tr>
</table>
<table style="width: 100%;" class="summary-table">
<tr class="table-heading-color">
<th class="summary" colspan="2">
Macro summary</th>
</tr>
<tr class="table-row-color">
<td class="summary-name">
<a href="cursor.html#_g3792">
alambda</a>
</td>
<td class="summary">
parms <em>&amp;body</em> body</td>
</tr>
<tr class="table-row-color">
<td class="summary-name">
<a href="cursor.html#_g3794">
alet</a>
</td>
<td class="summary">
letargs <em>&amp;rest</em> body</td>
</tr>
<tr class="table-row-color">
<td class="summary-name">
<a href="cursor.html#_g3793">
dlambda</a>
</td>
<td class="summary">
<em>&amp;rest</em> dispatch-table</td>
</tr>
<tr class="table-row-color">
<td class="summary-name">
<a href="cursor.html#_g3795">
with-cursor</a>
</td>
<td class="summary">
(name collection) <em>&amp;body</em> body</td>
</tr>
</table>
<div class="defparam">
<div class="defunsignatures">
<a id="_g3796">
</a>
<table cellpadding="0" cellspacing="0" width="100%">
<colgroup span="3">
<col width="0*"/>
<col width="1*"/>
<col width="0*"/>
</colgroup>
<tbody>
<tr>
<td class="symbol-name">
+end+&nbsp;&nbsp;</td>
<td class="lambda-list">
</td>
<td class="symbol-type">
&nbsp;[Variable]</td>
</tr>
</tbody>
</table>
</div>
</div>
<div class="defun">
<div class="defunsignatures">
<a id="_g3797">
</a>
<table cellpadding="0" cellspacing="0" width="100%">
<colgroup span="3">
<col width="0*"/>
<col width="1*"/>
<col width="0*"/>
</colgroup>
<tbody>
<tr>
<td class="symbol-name">
make-cursor&nbsp;&nbsp;</td>
<td class="lambda-list">
collection</td>
<td class="symbol-type">
&nbsp;[Function]</td>
</tr>
</tbody>
</table>
</div>
</div>
<div class="defun">
<div class="defunsignatures">
<a id="_g3792">
</a>
<table cellpadding="0" cellspacing="0" width="100%">
<colgroup span="3">
<col width="0*"/>
<col width="1*"/>
<col width="0*"/>
</colgroup>
<tbody>
<tr>
<td class="symbol-name">
alambda&nbsp;&nbsp;</td>
<td class="lambda-list">
parms <em>&amp;body</em> body</td>
<td class="symbol-type">
&nbsp;[Macro]</td>
</tr>
</tbody>
</table>
</div>
</div>
<div class="defun">
<div class="defunsignatures">
<a id="_g3793">
</a>
<table cellpadding="0" cellspacing="0" width="100%">
<colgroup span="3">
<col width="0*"/>
<col width="1*"/>
<col width="0*"/>
</colgroup>
<tbody>
<tr>
<td class="symbol-name">
dlambda&nbsp;&nbsp;</td>
<td class="lambda-list">
<em>&amp;rest</em> dispatch-table</td>
<td class="symbol-type">
&nbsp;[Macro]</td>
</tr>
</tbody>
</table>
</div>
</div>
<div class="defun">
<div class="defunsignatures">
<a id="_g3794">
</a>
<table cellpadding="0" cellspacing="0" width="100%">
<colgroup span="3">
<col width="0*"/>
<col width="1*"/>
<col width="0*"/>
</colgroup>
<tbody>
<tr>
<td class="symbol-name">
alet&nbsp;&nbsp;</td>
<td class="lambda-list">
letargs <em>&amp;rest</em> body</td>
<td class="symbol-type">
&nbsp;[Macro]</td>
</tr>
</tbody>
</table>
</div>
</div>
<div class="defun">
<div class="defunsignatures">
<a id="_g3795">
</a>
<table cellpadding="0" cellspacing="0" width="100%">
<colgroup span="3">
<col width="0*"/>
<col width="1*"/>
<col width="0*"/>
</colgroup>
<tbody>
<tr>
<td class="symbol-name">
with-cursor&nbsp;&nbsp;</td>
<td class="lambda-list">
(name collection) <em>&amp;body</em> body</td>
<td class="symbol-type">
&nbsp;[Macro]</td>
</tr>
</tbody>
</table>
</div>
<div class="doc-body">
<p>
Within the scope of BODY, Bind a stateful closure to a function called NAME 
 that may then be called repeatedly with various optional parameters in order 
 to effect a number of useful operations on the given collection that may be 
 both conceptually simpler to implement and possibly more efficient than 
 it would be to accomplish the equivalent using a functional approach such 
 as mapping and reducing. In a basic sense a cursor is similar in spirit to 
 the 'iterator' facilities present in common-lisp (package iterator, sequence 
 iterator, ...) however there are a number of additional capabilities beyond 
 just simple traversal provided by those iterator facilities. Most significantly, 
 the cursor implementation is based on the pandoric closure techniques described 
 in Doug Hoyte's 'Let Over Lambda', and, as such, is fully extensible -- not 
 only in terms of further development, but also at 'runtime' a new dispatching 
 dlambda can be hotpatched into a running cursor instance, offering pretty much 
 unlimited ways in which one can dynamically effect behavior and implement 
 interesting functionality. The following table describes the basic cursor 
 functions currently provided by the default cursor implementation: 
 </p>
<p>
(&lt;cursor&gt; <span class="keyword">
:whole) </span>

 
 Return the full and exact (eq) collection that this cursor 
 was originally invoked on, as the closure maintains a reference 
 to it for the duration of its lifetime, unless acted upon; see <span class="keyword">
:reset, </span>
below. 
 </p>
<p>
(&lt;cursor&gt; <span class="keyword">
:reset) </span>

 (&lt;cursor&gt; <span class="keyword">
:reset </span>
NEW-COLLECTION) 
 
 On initial construction and when invoked by the user, the <span class="keyword">
:reset </span>
dispatch 
 clears and initializes all internal state maintained by the cursor and performs 
 the initial housekeeping required to prepare for traversal of NEW-COLLECTION. 
 As a special case, on <span class="keyword">
:RESET </span>
invocations subsequent to the first, if called 
 with no NEW-COLLECTION specified, it will by default prepare for a fresh 
 traversal of the original collection. 
 </p>
<p>
(&lt;cursor&gt; <span class="keyword">
:state) </span>

 </p>
<p>
The various parameters that comprise the cursor's internal state may be 
 inspected by calling the <span class="keyword">
:STATE </span>
dispatch, which will return a plist that 
 explicitly describes its current dynamic state. 
 
 (&lt;cursor&gt; <span class="keyword">
:at) </span>

 </p>
<p>
Return the collection constituent that is directly 'under' the cursor at 
 the present, without advancing the cursor afterwards. Ie, the cursor will 
 remain at the same point and if <span class="keyword">
:AT </span>
were to be invoked again, the same 
 constituent would again be returned. 
 
 (&lt;cursor&gt; <span class="keyword">
:elt </span>
N) 
 </p>
<p>
Move the cursor directly to the Nth element and return that value. This 
 index is based on a 0-origin to maintain the same semantics as the corresponding 
 common-lisp sequence lib. 
 </p>
<p>
(&lt;cursor&gt; <span class="keyword">
:collect) </span>

 (&lt;cursor&gt; <span class="keyword">
:collect </span>
N) 
 </p>
<p>
Collect provides a convenient means of aggregating specific elements of the 
 collection, similarly to other familiar collect macros, such as used with loop. 
 Thus, when used with the cursor, one can browse the collection in any order, 
 backwards and forwards to pick and choose elements and collect them as you see fit. 
 In addition, if an argument N is provided, <span class="keyword">
:collect </span>
will attempt to collect that 
 many elements, starting from the initial collection position. 
 </p>
<p>
(&lt;cursor&gt; <span class="keyword">
:clear) </span>

 </p>
<p>
The contents of the <span class="keyword">
:COLLECT </span>
accumulator as described above are cleared and the 
 cursor state will be as having collected no elements.t 
 </p>
<p>
(&lt;cursor&gt; <span class="keyword">
:next) </span>

 (&lt;cursor&gt; <span class="keyword">
:prev) </span>

 </p>
<p>
Advance the cursor one step in the respective direction, returning the value of 
 the element positioned there. 
 </p>
<p>
(&lt;cursor&gt; <span class="keyword">
:nextp) </span>

 (&lt;cursor&gt; <span class="keyword">
:prevp) </span>

 </p>
<p>
Boolean predicate which may be invoked in order to determine if any further 
 elements exist in the corresponding direction. Thus at the beginning of 
 a sequence prevp is nil, at the end nextp is nil. 
 </p>
<p>
(&lt;cursor&gt; <span class="keyword">
:remain) </span>

 </p>
<p>
The <span class="keyword">
:remain </span>
dispatch returns the total number of elements which remain between 
 the current position of the cursor and the end of the sequence. Thus, the 
 'rest' of a sequence may be easily obtained by executing a form like 
 (cursor <span class="keyword">
:collect </span>
(cursor <span class="keyword">
:remain)). </span>
Note, however that since the cursor is 
 always free to backtrack as well, the <span class="keyword">
:remain </span>
will increase again as one moves 
 back towards the 'front' of the sequence. 
 </p>
<p>
(&lt;cursor&gt; <span class="keyword">
:forward </span>
N) 
 (&lt;cursor&gt; <span class="keyword">
:backward </span>
N) 
 </p>
<p>

 (&lt;cursor&gt; <span class="keyword">
:format </span>
STREAM CONTROL-STRING) 
 </p>
<p>
(&lt;cursor&gt; <span class="keyword">
:?) </span>

 </p>
</div>
</div>
</div>
<div class="cludg-footer">
Generated by&nbsp;<a href="mailto:ihatchondo@common-lisp.net" lang="en">
CLDOC</a>
- 2012-02-23 02:12:07</div>
</body>
</html>
